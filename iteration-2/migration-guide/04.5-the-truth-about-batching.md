# Step 4.5: The Truth About Batching in SolidJS

## ðŸŽ¯ The Critical Question You Should Ask

**"If I update two signals, how many times does my effect run?"**

Let's find out with REAL SolidJS behavior.

---

## ðŸ§ª The Glitch Test

```typescript
const [firstName, setFirstName] = createSignal("John");
const [lastName, setLastName] = createSignal("Doe");

const fullName = createMemo(() => {
  console.log("Computing fullName");
  return `${firstName()} ${lastName()}`;
});

createEffect(() => {
  console.log("Effect sees:", fullName());
});

// Test 1: WITHOUT batch()
console.log("=== Test 1: Separate Updates ===");
setFirstName("Jane");
setLastName("Smith");

// Output:
// Computing fullName
// Effect sees: Jane Doe
// Computing fullName  
// Effect sees: Jane Smith
//
// Effect ran TWICE! This is a GLITCH! ðŸ˜±
```

---

## ðŸš¨ THE TRUTH: No Automatic Batching!

### Without `batch()`, effects run after EVERY signal update:

```typescript
setFirstName("Jane");
// â†“ SYNCHRONOUS EXECUTION:
// 1. Mark fullName as STALE
// 2. Mark effect as STALE
// 3. Add fullName to Updates queue
// 4. Add effect to Effects queue
// 5. Flush Updates queue (fullName computes)
// 6. Flush Effects queue (effect runs)
// 7. Clear queues: Updates = null, Effects = null
// 8. RETURN
// â†‘ All done BEFORE next line!

setLastName("Smith");
// â†“ SYNCHRONOUS EXECUTION (AGAIN):
// 1. Mark fullName as STALE
// 2. Mark effect as STALE
// 3. Create NEW Updates queue
// 4. Create NEW Effects queue
// 5. Flush Updates queue (fullName computes AGAIN)
// 6. Flush Effects queue (effect runs AGAIN)
// 7. Clear queues
// 8. RETURN

// Result: Effect ran TWICE with intermediate values!
```

---

## âœ… The Solution: Manual `batch()`

```typescript
console.log("=== Test 2: With batch() ===");

batch(() => {
  setFirstName("Jane");
  setLastName("Smith");
});

// Output:
// Computing fullName
// Effect sees: Jane Smith
//
// Effect ran ONCE! No glitch! ðŸŽ‰
```

### How `batch()` Actually Works:

```typescript
export function batch<T>(fn: () => T): T {
  return runUpdates(fn, false);
}
```

The magic is in `runUpdates`:

```typescript
function runUpdates(fn, init) {
  if (Updates) return fn();  // â† THE KEY!
  
  let wait = false;
  if (!init) Updates = [];
  if (Effects) wait = true;
  else Effects = [];
  
  try {
    fn();  // Execute the batch function
    completeUpdates(wait);
  } finally {
    if (!wait) Effects = null;
    Updates = null;
  }
}
```

**Inside `batch()`:**

```typescript
batch(() => {
  // runUpdates creates Updates and Effects queues
  
  setFirstName("Jane");
  // â†“
  // writeSignal calls runUpdates
  // if (Updates) return fn();  â† Updates EXISTS!
  // So it JUST marks, doesn't flush!
  
  setLastName("Smith");
  // â†“
  // writeSignal calls runUpdates
  // if (Updates) return fn();  â† Updates STILL EXISTS!
  // So it JUST marks, doesn't flush!
});
// â†‘ NOW flush happens ONCE with both changes!
```

---

## ðŸ“Š The Complete Flow Comparison

### Without batch() (Glitches):

```
setFirstName("Jane")
  â†“
  runUpdates(mark, false)
    â†“
    Updates = []     â† Create queue
    Effects = []     â† Create queue
    â†“
    Mark observers as STALE
    â†“
    completeUpdates(wait=false)
      â†“
      Flush Updates  â†’ fullName computes: "Jane Doe"
      Flush Effects  â†’ effect sees: "Jane Doe" âœ…
      â†“
      Updates = null â† Clear
      Effects = null â† Clear
  â†“
  RETURN

setLastName("Smith")
  â†“
  runUpdates(mark, false)
    â†“
    Updates = []     â† Create AGAIN (was null!)
    Effects = []     â† Create AGAIN (was null!)
    â†“
    Mark observers as STALE
    â†“
    completeUpdates(wait=false)
      â†“
      Flush Updates  â†’ fullName computes: "Jane Smith"
      Flush Effects  â†’ effect sees: "Jane Smith" âœ…
      â†“
      Updates = null â† Clear
      Effects = null â† Clear
  â†“
  RETURN

Result: Effect ran TWICE! ðŸ˜±
```

### With batch() (No Glitches):

```
batch(() => { ... })
  â†“
  runUpdates(batchFn, false)
    â†“
    Updates = []     â† Create ONCE
    Effects = []     â† Create ONCE
    â†“
    batchFn() executes:
      â†“
      setFirstName("Jane")
        â†“
        runUpdates(mark, false)
          â†“
          if (Updates) return fn();  â† YES! Just mark, don't flush
      â†“
      setLastName("Smith")
        â†“
        runUpdates(mark, false)
          â†“
          if (Updates) return fn();  â† YES! Just mark, don't flush
    â†“
    completeUpdates(wait=false)
      â†“
      Flush Updates  â†’ fullName computes ONCE: "Jane Smith"
      Flush Effects  â†’ effect sees ONCE: "Jane Smith" âœ…
      â†“
      Updates = null â† Clear
      Effects = null â† Clear
  â†“
  RETURN

Result: Effect ran ONCE! ðŸŽ‰
```

---

## ðŸŽ¯ When Do You Need `batch()`?

### âœ… NEED `batch()` (Multiple related updates):

```typescript
// User form update
batch(() => {
  setName(formData.name);
  setEmail(formData.email);
  setAge(formData.age);
});
// Effect runs ONCE with all new values

// State machine transition
batch(() => {
  setState("loading");
  setError(null);
  setProgress(0);
});
// UI updates ONCE

// Animation
batch(() => {
  setX(100);
  setY(200);
  setRotation(45);
});
// Render ONCE with final position
```

### âŒ DON'T NEED `batch()` (Single update):

```typescript
// Just one signal
setCount(5);
// Effect runs once anyway

// Already in a batch context
batch(() => {
  // These are already batched
  setA(1);
  batch(() => {
    setB(2);  // Nested batch is redundant
  });
});

// In event handlers (framework auto-batches)
<button onClick={() => {
  setCount(5);
  setName("John");
  // SolidJS wraps event handlers in batch() automatically!
}}>
```

---

## ðŸ” Why The Confusion?

You might see code that uses `init=false`:

```typescript
writeSignal(signal, value) {
  runUpdates(() => {
    // mark observers
  }, false);  // â† init=false
}
```

**Common Misconception:** "init=false enables automatic batching!"

**Reality:** `init=false` only matters **within a single `runUpdates` call**.

### The `wait` Flag Explained:

```typescript
function runUpdates(fn, init) {
  if (Updates) return fn();
  
  let wait = false;
  if (!init) Updates = [];
  if (Effects) wait = true;   // â† Check if Effects exists
  else Effects = [];
  
  try {
    fn();
    completeUpdates(wait);
  } finally {
    if (!wait) Effects = null;  // â† Clear Effects!
    Updates = null;
  }
}
```

**The Problem:**

```typescript
// First setSignal:
// Effects = null â†’ wait = false â†’ flush Effects â†’ Effects = null âœ…

// Second setSignal:
// Effects = null (was cleared!) â†’ wait = false â†’ flush Effects AGAIN âœ…

// So no batching across separate setSignal calls!
```

The `wait` flag only helps **within one `runUpdates` call**, like when `batch()` calls `runUpdates`.

---

## ðŸ’¡ Key Takeaways

### 1. **Effects Flush SYNCHRONOUSLY**

```typescript
setSignal(value);
// â† Effect ALREADY ran (synchronously)
console.log("next line");
```

No microtasks, no promises, no async. Pure synchronous execution.

### 2. **Multiple Updates = Multiple Flushes (Without batch)**

```typescript
setA(1);  // Effect runs
setB(2);  // Effect runs AGAIN
setC(3);  // Effect runs AGAIN
// Total: 3 effect runs
```

### 3. **`batch()` is REQUIRED for Multiple Updates**

```typescript
batch(() => {
  setA(1);
  setB(2);
  setC(3);
});
// Total: 1 effect run
```

### 4. **Event Handlers Auto-Batch**

```typescript
<button onClick={() => {
  setA(1);
  setB(2);
  // SolidJS framework wraps this in batch()
}}>
// Total: 1 effect run (automatic!)
```

But this is **framework-level**, not reactive-core-level!

---

## ðŸ§ª Test It Yourself

```typescript
import { createSignal, createEffect, batch } from "solid-js";

const [a, setA] = createSignal(0);
const [b, setB] = createSignal(0);

let runs = 0;
createEffect(() => {
  console.log(`Run #${++runs}: a=${a()}, b=${b()}`);
});

console.log("\n=== Without batch ===");
setA(1);  // Run #2: a=1, b=0
setB(2);  // Run #3: a=1, b=2

console.log("\n=== With batch ===");
batch(() => {
  setA(3);
  setB(4);
});  // Run #4: a=3, b=4 (only once!)

console.log("\nTotal runs:", runs);
// Total runs: 4
// - 1 initial
// - 2 from separate setA/setB
// - 1 from batched setA+setB
```

---

## ðŸŽ¯ Mental Model

Think of SolidJS reactivity like **synchronous function calls**:

```typescript
// This:
setA(1);
setB(2);

// Is like:
markAndFlushEffect(); // From setA
markAndFlushEffect(); // From setB

// To batch:
batch(() => {
  setA(1);
  setB(2);
});

// Is like:
markAllEffects();
flushAllEffects(); // Once!
```

---

## ðŸš€ Next Step

Now that you understand batching, continue to **[05-computation-states.md](./05-computation-states.md)** to learn about lazy evaluation and the state machine.

---

**ðŸ’¡ Remember:** In real SolidJS, **you control batching**. No magic, no automatic batching without `batch()`. This gives you predictable, controllable behavior!
