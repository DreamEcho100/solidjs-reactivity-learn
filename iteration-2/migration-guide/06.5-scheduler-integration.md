# Step 6.5: Scheduler Integration & Browser Responsiveness

## ğŸ¯ Goal
Understand Solid.js's task scheduler that keeps the browser responsive during long update cycles.

## ğŸ¤” The Problem: Blocking Updates

### Without a Scheduler

```javascript
// Imagine 10,000 components updating at once
for (let i = 0; i < 10000; i++) {
  updateComponent(i);
}
// Browser frozen for 500ms!
// Can't scroll, click, or type ğŸ˜±
```

**Problems:**
1. **Long tasks block browser** - No interaction during updates
2. **Poor user experience** - Feels janky and unresponsive
3. **No prioritization** - Important updates wait for unimportant ones

### With Solid's Scheduler

```typescript
// Break work into chunks
requestCallback(() => {
  // Do some work...
  
  // Check: Should we yield to browser?
  if (shouldYieldToHost()) {
    return; // Let browser breathe, continue later
  }
  
  // Continue working...
});
```

---

## ğŸ“Š The Scheduler System

### Core Components

```typescript
// From scheduler.ts
export interface Task {
  id: number;
  fn: ((didTimeout: boolean) => void) | null;
  startTime: number;
  expirationTime: number;
}

// Internal state
let taskIdCounter = 1;
let isCallbackScheduled = false;
let isPerformingWork = false;
let taskQueue: Task[] = [];
let currentTask: Task | null = null;
let shouldYieldToHost: (() => boolean) | null = null;
let yieldInterval = 5; // ms
let deadline = 0;
let maxYieldInterval = 300; // ms
let maxDeadline = 0;
```

### Time Budget System

```
Browser Frame (16.67ms for 60fps):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 5ms work â†’ Check â†’ 5ms work â†’ Check â”‚
â”‚           â†“                â†“         â”‚
â”‚       Should yield?   Should yield?  â”‚
â”‚       No, continue    No, continue   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

If work exceeds 5ms:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 5ms work â†’ Check                    â”‚
â”‚           â†“                          â”‚
â”‚       Should yield?                  â”‚
â”‚       YES! (reached deadline)        â”‚
â”‚           â†“                          â”‚
â”‚       Yield to browser               â”‚
â”‚       Resume in next frame           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ—ï¸ Implementation

### Step 1: Setup Scheduler

```typescript
// From scheduler.ts
function setupScheduler() {
  const channel = new MessageChannel();
  const port = channel.port2;
  
  // Schedule callback using MessageChannel (faster than setTimeout)
  scheduleCallback = () => port.postMessage(null);
  
  // Handle scheduled work
  channel.port1.onmessage = () => {
    if (scheduledCallback !== null) {
      const currentTime = performance.now();
      deadline = currentTime + yieldInterval;
      maxDeadline = currentTime + maxYieldInterval;
      
      try {
        const hasMoreWork = scheduledCallback(currentTime);
        
        if (!hasMoreWork) {
          scheduledCallback = null;
        } else {
          port.postMessage(null); // Schedule next chunk
        }
      } catch (error) {
        port.postMessage(null);
        throw error;
      }
    }
  };
  
  // Setup yield detection
  if (navigator?.scheduling?.isInputPending) {
    shouldYieldToHost = () => {
      const currentTime = performance.now();
      
      if (currentTime >= deadline) {
        // Check if user is trying to interact
        if (navigator.scheduling.isInputPending()) {
          return true; // Yield for user input
        }
        
        // Max deadline reached?
        return currentTime >= maxDeadline;
      }
      
      return false; // Still have time
    };
  } else {
    // Fallback: just check deadline
    shouldYieldToHost = () => performance.now() >= deadline;
  }
}
```

### Step 2: Task Queue (Priority Queue)

```typescript
/**
 * Insert task sorted by expiration time (binary search)
 */
function enqueue(taskQueue: Task[], task: Task) {
  function findIndex() {
    let m = 0;
    let n = taskQueue.length - 1;
    
    while (m <= n) {
      const k = (n + m) >> 1; // Binary search midpoint
      const cmp = task.expirationTime - taskQueue[k].expirationTime;
      
      if (cmp > 0) m = k + 1;      // Task expires later
      else if (cmp < 0) n = k - 1; // Task expires sooner
      else return k;                // Same expiration
    }
    
    return m; // Insert position
  }
  
  taskQueue.splice(findIndex(), 0, task);
}
```

**Example:**

```
Task Queue (sorted by expiration):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Task A (expires: 100ms)        â”‚ â† Most urgent
â”‚ Task B (expires: 150ms)        â”‚
â”‚ Task C (expires: 200ms)        â”‚
â”‚ Task D (expires: 500ms)        â”‚ â† Least urgent
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

New Task E (expires: 175ms) arrives:
Binary search finds position â†’ Insert between B and C

Result:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Task A (expires: 100ms)        â”‚
â”‚ Task B (expires: 150ms)        â”‚
â”‚ Task E (expires: 175ms)        â”‚ â† Inserted
â”‚ Task C (expires: 200ms)        â”‚
â”‚ Task D (expires: 500ms)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Step 3: Work Loop

```typescript
function workLoop(initialTime: number): boolean {
  let currentTime = initialTime;
  currentTask = taskQueue[0] || null;
  
  while (currentTask !== null) {
    // Check if we should yield
    if (
      currentTask.expirationTime > currentTime && // Not expired
      shouldYieldToHost!()                         // Time to yield
    ) {
      break; // Yield to browser
    }
    
    const callback = currentTask.fn;
    
    if (callback !== null) {
      currentTask.fn = null; // Clear to prevent re-run
      
      const didUserCallbackTimeout = 
        currentTask.expirationTime <= currentTime;
      
      callback(didUserCallbackTimeout);
      
      currentTime = performance.now();
      
      // Remove completed task
      if (currentTask === taskQueue[0]) {
        taskQueue.shift();
      }
    } else {
      taskQueue.shift(); // Remove cancelled task
    }
    
    currentTask = taskQueue[0] || null;
  }
  
  // Return whether there's more work
  return currentTask !== null;
}
```

### Step 4: Request Callback API

```typescript
/**
 * Schedule a callback to run with optional timeout
 */
export function requestCallback(
  fn: () => void,
  options?: { timeout: number }
): Task {
  if (!scheduleCallback) setupScheduler();
  
  const startTime = performance.now();
  const timeout = options?.timeout ?? maxSigned31BitInt;
  
  const newTask: Task = {
    id: taskIdCounter++,
    fn,
    startTime,
    expirationTime: startTime + timeout
  };
  
  enqueue(taskQueue, newTask);
  
  if (!isCallbackScheduled && !isPerformingWork) {
    isCallbackScheduled = true;
    scheduledCallback = flushWork;
    scheduleCallback!();
  }
  
  return newTask;
}

/**
 * Cancel a scheduled task
 */
export function cancelCallback(task: Task) {
  task.fn = null; // Mark as cancelled
}
```

---

## ğŸ”„ Integration with Solid.js

### How Solid Uses the Scheduler

```typescript
// From signal.ts
let Scheduler: ((fn: () => void) => any) | null = null;

// In completeUpdates:
function completeUpdates(wait: boolean) {
  if (Updates) {
    // During transitions, use scheduler
    if (Scheduler && Transition && Transition.running) {
      scheduleQueue(Updates);
    } else {
      runQueue(Updates);
    }
    Updates = null;
  }
  
  // ... effects ...
}

function scheduleQueue(queue: Computation<any>[]) {
  for (let i = 0; i < queue.length; i++) {
    scheduleTask(queue[i]);
  }
}

function scheduleTask(node: Computation<any>) {
  // Schedule with scheduler
  Scheduler!(() => {
    runTop(node);
  });
}
```

### When Scheduling Happens

```
Normal Update (No Transition):
setSignal(value) â†’ runUpdates â†’ runQueue(Updates) â†’ runQueue(Effects)
                   Synchronous, immediate

Transition Update:
startTransition(() => setSignal(value))
  â†’ runUpdates
  â†’ scheduleQueue(Updates)     â† Uses scheduler!
  â†’ Chunks work across frames
  â†’ Keeps UI responsive
```

---

## ğŸ¨ Visual Example

### Synchronous Update

```typescript
const [count, setCount] = createSignal(0);

// Create 10,000 memos
const memos = Array.from({ length: 10000 }, (_, i) =>
  createMemo(() => count() + i)
);

// This blocks for ~50ms
setCount(1);
// â† Browser frozen during update
```

**Timeline:**

```
Frame 1: [====================================] Update (50ms)
         User clicks â†’ Ignored! ğŸ˜±
Frame 2: [          ] Idle
Frame 3: [          ] Idle
```

### Scheduled Update

```typescript
const [count, setCount] = createSignal(0);

const memos = Array.from({ length: 10000 }, (_, i) =>
  createMemo(() => count() + i)
);

// This yields to browser
startTransition(() => {
  setCount(1);
});
// â† Browser stays responsive
```

**Timeline:**

```
Frame 1: [====] Work (5ms) â†’ Yield
         User clicks â†’ Handled! âœ…
Frame 2: [====] Work (5ms) â†’ Yield
         User types â†’ Handled! âœ…
Frame 3: [====] Work (5ms) â†’ Yield
...
Frame 10: [==] Work (2ms) â†’ Done!
```

---

## ğŸ” Advanced Features

### Input Pending Detection

```typescript
// Modern browsers support isInputPending
if (navigator.scheduling.isInputPending()) {
  // User is trying to interact!
  return true; // Yield immediately
}
```

**Benefits:**
- Detects clicks, keyboard, scroll before they're processed
- Yield only when necessary
- Better responsiveness

### Time Budgets

```typescript
const yieldInterval = 5;        // Yield after 5ms
const maxYieldInterval = 300;   // Force yield after 300ms
```

**Why two budgets?**

1. **Short budget (5ms):** Check frequently, yield if input pending
2. **Long budget (300ms):** Force yield even without input (prevent starvation)

---

## ğŸ§ª Testing

### Test 1: Basic Scheduling

```typescript
test("schedules task", async () => {
  let executed = false;
  
  requestCallback(() => {
    executed = true;
  });
  
  // Wait for next frame
  await new Promise(resolve => setTimeout(resolve, 0));
  
  expect(executed).toBe(true);
});
```

### Test 2: Priority Order

```typescript
test("executes tasks in priority order", async () => {
  const order: number[] = [];
  
  // Schedule tasks with different timeouts
  requestCallback(() => order.push(2), { timeout: 100 });
  requestCallback(() => order.push(1), { timeout: 50 });
  requestCallback(() => order.push(3), { timeout: 150 });
  
  await new Promise(resolve => setTimeout(resolve, 200));
  
  expect(order).toEqual([1, 2, 3]);
});
```

### Test 3: Cancellation

```typescript
test("can cancel task", async () => {
  let executed = false;
  
  const task = requestCallback(() => {
    executed = true;
  });
  
  cancelCallback(task);
  
  await new Promise(resolve => setTimeout(resolve, 0));
  
  expect(executed).toBe(false);
});
```

---

## ğŸ“Š Performance Impact

### Without Scheduler

```
Long Task (200ms):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Frame 1: [====================]    â”‚ 200ms (BLOCKING!)
â”‚ Frame 2: [    ]                    â”‚ 16ms (normal)
â”‚ Frame 3: [    ]                    â”‚ 16ms (normal)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

User Experience:
- Frozen for 200ms
- Janky interaction
- Input lag
```

### With Scheduler

```
Chunked Work (200ms total):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Frame 1:  [==]                     â”‚ 5ms work + 11ms idle
â”‚ Frame 2:  [==]                     â”‚ 5ms work + 11ms idle
â”‚ Frame 3:  [==]                     â”‚ 5ms work + 11ms idle
â”‚ Frame 4:  [==]                     â”‚ 5ms work + 11ms idle
â”‚ ...                                â”‚
â”‚ Frame 40: [==]                     â”‚ 5ms work + 11ms idle
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

User Experience:
- Always responsive
- Smooth interaction
- No input lag
```

---

## âœ… Implementation Checklist

- [ ] Understand MessageChannel for scheduling
- [ ] Implement priority queue with binary search
- [ ] Add yield detection (deadline + input pending)
- [ ] Integrate with Transition system
- [ ] Test with large update batches
- [ ] Measure frame times in DevTools
- [ ] Compare sync vs scheduled performance

---

## ğŸš€ Next Step

Continue to **[07-memo-implementation.md](./07-memo-implementation.md)** to implement production-ready memos.

---

## ğŸ’¡ Key Takeaways

**The scheduler is about responsiveness:**
- Break long work into small chunks (5ms)
- Yield to browser between chunks
- Prioritize urgent tasks
- Detect user input and yield immediately
- Keep UI smooth even during heavy updates

**When to use:**
- Transitions (non-urgent updates)
- Large batch updates
- Async data loading
- Background computations

**When NOT to use:**
- Critical immediate updates
- Small, fast operations
- Synchronous rendering

---

**Pro Tip:** The scheduler is what makes `startTransition()` possible. Without it, transitions would still block the browser!
